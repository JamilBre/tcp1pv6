// cli_tcp_ipv6_linux.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>      // Proporciona acceso a la API del sistema operativo POSIX (como close())
#include <arpa/inet.h>   // Funciones para manipular direcciones de red (como inet_pton)
#include <sys/socket.h>  // Definiciones principales para la creación y manejo de sockets

#define BUFFSIZE 256     // Tamaño del búfer (memoria temporal) para enviar/recibir datos

// -----------------------------------------------------------------------------
// MÓDULO 1: Manejo de Errores
// -----------------------------------------------------------------------------
// Imprime un mensaje descriptivo del error junto con el error del sistema operativo y termina el programa.
void AvisarError(char *mensaje) {
    perror(mensaje);
    exit(1);
}

// -----------------------------------------------------------------------------
// MÓDULO 2: Función Principal (Ejecución del Cliente)
// -----------------------------------------------------------------------------
int main(int argc, char *argv[]) {

    int sock;                           // Descriptor del socket del cliente
    struct sockaddr_in6 echoserver;     // Estructura para guardar la dirección IPv6 del servidor al que nos conectaremos
    char buffer[BUFFSIZE];              // Búfer para guardar los mensajes
    int echolen;                        // Longitud del mensaje que el usuario va a escribir
    int received = 0;                   // Contador de bytes que hemos recibido como respuesta

    // Verifica que el usuario haya ejecutado el programa con los argumentos correctos (IP y Puerto)
    if (argc != 3) {
        fprintf(stderr, "USO: Cliente <ip_servidor_ipv6> <puerto>\n");
        exit(1);
    }

    // PASO 1: Crear el socket
    // AF_INET6 = Familia IPv6 | SOCK_STREAM = Protocolo TCP | 0 = Selecciona automáticamente el protocolo base (TCP)
    printf("[CLIENTE] Creando socket TCP IPv6...\n");
    if ((sock = socket(AF_INET6, SOCK_STREAM, 0)) < 0) {
        AvisarError("No se pudo crear socket");
    }
    printf("[CLIENTE] Socket creado correctamente.\n");

    // PASO 2: Configurar la dirección del servidor de destino
    memset(&echoserver, 0, sizeof(echoserver)); // Llenamos la estructura con ceros por seguridad
    echoserver.sin6_family = AF_INET6;          // Indicamos que usaremos IPv6
    echoserver.sin6_port = htons(atoi(argv[2]));// Convertimos el puerto de texto a número y luego al formato de red (htons)

    // Convertimos la dirección IP de formato texto (ej. "::1") a formato binario de red
    printf("[CLIENTE] Resolviendo direccion IPv6 del servidor: %s...\n", argv[1]);
    if (inet_pton(AF_INET6, argv[1], &echoserver.sin6_addr) <= 0) {
        AvisarError("Direccion IPv6 invalida");
    }

    // PASO 3: Conectar al servidor (Inicia el 3-Way Handshake de TCP)
    printf("[CLIENTE] Iniciando peticion de conexion (SYN)...\n");
    if (connect(sock, (struct sockaddr *) &echoserver, sizeof(echoserver)) < 0) {
        AvisarError("No se pudo conectar al servidor");
    }
    printf("[CLIENTE] [3-WAY HANDSHAKE COMPLETADO] Conexion establecida.\n");

    // PASO 4: Recibir el mensaje inicial del servidor ("Envia el mensaje: ")
    printf("[CLIENTE] [RX] Esperando mensaje inicial del servidor...\n");
    memset(buffer, 0, BUFFSIZE); // Limpiamos el búfer antes de leer

    if (recv(sock, buffer, BUFFSIZE - 1, 0) > 0) {
        printf(">> %s", buffer); // Imprimimos la solicitud del servidor
    } else {
        AvisarError("No se recibio respuesta del servidor");
    }

    // PASO 5: Capturar la entrada del usuario por teclado
    memset(buffer, 0, BUFFSIZE);
    if (fgets(buffer, BUFFSIZE, stdin) == NULL) { // stdin captura lo que escribes en la terminal
        AvisarError("Error al leer entrada del usuario");
    }

    echolen = strlen(buffer); // Calculamos cuánto mide el mensaje que acabamos de escribir

    // PASO 6: Enviar los datos al servidor
    printf("\n[CLIENTE] [TX] Enviando datos (%d bytes)...\n", echolen);
    if (send(sock, buffer, echolen, 0) != echolen) {
        AvisarError("Error enviando datos");
    }

    printf("Mensaje original enviado: %s", buffer);
    printf("Recibido (Cifrado): ");

    printf("\n[CLIENTE] [RX] Esperando respuesta cifrada...\n");

    // PASO 7: Recibir la respuesta cifrada del servidor
    // Usamos un bucle 'while' porque TCP es un flujo (stream) de datos. 
    // Un mensaje grande podría llegar dividido en varios fragmentos o paquetes, 
    // así que leemos hasta que hayamos recibido la misma cantidad de bytes que enviamos.
    while (received < echolen) {
        int bytes;
        memset(buffer, 0, BUFFSIZE);

        if ((bytes = recv(sock, buffer, BUFFSIZE - 1, 0)) <= 0) {
            AvisarError("Error recibiendo datos");
        }

        received += bytes;    // Sumamos los bytes recibidos en esta iteración al total
        printf("%s", buffer); // Imprimimos este fragmento del mensaje cifrado
    }

    printf("\n[CLIENTE] Total de datos cifrados recibidos correctamente.\n");

    // PASO 8: Cerrar la conexión
    printf("[CLIENTE] Cerrando conexion (FIN)...\n");
    close(sock); // Cierra el socket del cliente en Linux

    printf("[CLIENTE] Conexion terminada.\n");

    return 0; // Finaliza el programa correctamente
}
